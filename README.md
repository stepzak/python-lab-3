# Лабораторная работа 3

**Цель**: познакомиться с некоторыми алгоритмами и структурами данных
**Библиотеки**: *math*, *logging*, *dataclass*, *pytest*, *tabulate*, *timeit*, *collections*, *abc*, *typing*

## Факториал
    
### Рекурсивно:

1. если n = 1 или n = 0, возвращаем 1
2. иначе, возвращаем n*factorial(n-1)

### Итеративно:
1. пусть изначальный результат 1
2. пробегаемся i по числам от 1 до n, домножаем результат на i
3. возвращаем полученный результат

## Фибоначчи 

### Рекурсивно:
1. если n = 0 или 1: возвращаем n
2. возвращаем fibonacci(n-1)+fibonacci(n-2)

### Итеративно:
1. если n = 0, возвращаем 0
2. a, b = 0, 1
3. пробегаемся по числам до n-1: a, b = b,  a + b
4. возвращаем b


### Сортировки

## Пузырьковая
1. пока весь массив не отсортирован, пробегаемся по всем элементам так, что 
    1. если предыдущий элепмент больше текущего, меняем их местами
   2. запрещаем выходить из цикла

## Быстрая
1. пусть **low**, **high** - границы, в которых сканируем массив
2. пусть **pivot** - медиана первого, среднего и последнего элементов, меняем **pivot** местами с последним элементом
3. тогда введем указатели **i** и **j**, такие что:
    * **i** указывает на последний элемент, не больше чем **pivot**, равен low - 1
    * **j** пробегается по массиву в заданных границах так, что:
        
        1. если элемент больше **pivot**, идем дальше
        
        2. если элемент меньше либо равен **pivot**, увеличиваем **i** на 1, меняем текущий элемент с элементом на позиции **i** местами
4. меняем элемент на позиции **i+1** и **pivot** местами
5. сортируем все, что меньше **pivot**(берем **high** справа от **i+1**)
6. сортируем все, что больше **pivot**(берем **low** слева от **i-1**)
7. возвращаем отсортрованные слева и справа списки, между ними **pivot**

## Count

1. создаем массив подсчета размером от минимального до максимального значения в исходном массиве
2. пробегаемся по исходному массиву, заполняем массив подсчета
3. изменяем этот массив на массив кумулятивных сумм
4. пробегаемся по инвертированному исходному: индекс в результате будет равняться значению на индексе массива подсчета текущего элемента; уменьшаем префиксную сумму на 1

## Radix
1. берем максимальную длину числа в массиве
2. сортируем массив в соответствии с разрядами(передаем ключ для получения разряда в count sort)

## Bucket
1. Разделяем массив на корзины в соответствии с первой цифрой десятичной дроби
2. (Можно параллельно) сортируем каждое корзины с помощью quick sort
3. Объединяем все корзины в массив

## Бенчмарки:

| Algorithm   |        sorted |   nearly_sorted_1% |   nearly_sorted_5% |   nearly_sorted_10% |     unique_1% |     unique_5% |    unique_10% |   reverse_sorted |    random_int |   random_int_distinct |   random_float |   random_float_normalized |
|-------------|---------------|--------------------|--------------------|---------------------|---------------|---------------|---------------|------------------|---------------|-----------------------|----------------|---------------------------|
| quick       |   0.000902144 |        0.00103758  |        0.000651565 |         0.000682342 |   3.4888e-06  |   1.88091e-05 |   4.17669e-05 |      0.000809157 |   0.000696965 |           0.000666319 |    0.000682297 |               0.000670011 |
| bubble      |   3.83525e-05 |        0.0259004   |        0.0301672   |         0.0361151   |   4.4824e-06  |   7.7709e-05  |   0.000290364 |      0.0494832   |   0.0439771   |           0.0449379   |    0.0438221   |               0.0438897   |
| radix       |   0.000421278 |        0.000416515 |        0.000428114 |         0.000433529 |   1.0319e-05  |   2.70061e-05 |   4.87467e-05 |      0.000417575 |   0.000454103 |           0.00058627  |  nan           |             nan           |
| heap        |   0.00127967  |        0.00126826  |        0.00127451  |         0.00127612  |   4.4642e-06  |   3.29318e-05 |   7.81117e-05 |      0.00109714  |   0.00124419  |           0.00122931  |    0.00124518  |               0.00123826  |
| bucket      | nan           |      nan           |      nan           |       nan           | nan           | nan           | nan           |    nan           | nan           |         nan           |  nan           |               0.000540274 |
| counting    |   0.000130216 |        0.000128981 |        0.000132868 |         0.000133789 |   2.56753e-05 |   3.70763e-05 |   4.16749e-05 |      0.000129949 |   0.000145589 |           0.000143962 |  nan           |             nan           |

## Вывод

1. Наиболее универсальная сортировка - быстрая, т.к. в среднем быстрее всего фильтрует любые числовые типы
2. При относительно маленьких диапозонах целых чисел count будет быстрее
3. Для целых чисел больших диапозонов быстрее использовать radix

Приложение поддерживает CLI и ключи с компараторами в сортировках

## Установить репозиторий
```pip install -e git+https://github.com/stepzak/python-lab-3#egg=python-lab-3```

```cd src/python-lab-3```

## Запустить
```python -m src.main```

```>>> help```
